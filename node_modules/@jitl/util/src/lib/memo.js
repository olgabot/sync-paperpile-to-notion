"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoizeWithLRU = exports.memoizeWithWeakMap = void 0;
const __1 = require("..");
const map_1 = require("./map");
const typeAssertions_1 = require("./typeAssertions");
function memoizeWithWeakMap(fn) {
    const root = {};
    return (...args) => {
        var _a;
        let node = root;
        for (const arg of args) {
            (_a = node.children) !== null && _a !== void 0 ? _a : (node.children = new WeakMap());
            node = (0, map_1.mapGetOrCreate)(node.children, arg, () => ({})).value;
        }
        if ('memo' in node) {
            return node.memo;
        }
        node.memo = fn(...args);
        return node.memo;
    };
}
exports.memoizeWithWeakMap = memoizeWithWeakMap;
function memoIsEmpty(node) {
    if ('memo' in node) {
        return false;
    }
    if (node.children) {
        return node.children.size === 0;
    }
    return true;
}
function memoizeWithLRU(limit, fn) {
    if (limit < 1) {
        return fn;
    }
    const root = {};
    const lru = [];
    const infinite = limit === Infinity;
    return (...args) => {
        var _a;
        let node = root;
        for (const arg of args) {
            (_a = node.children) !== null && _a !== void 0 ? _a : (node.children = new Map());
            node = (0, map_1.mapGetOrCreate)(node.children, arg, () => ({})).value;
        }
        if (node.memo) {
            if (!infinite) {
                lru.splice(lru.indexOf(node.memo.args), 1);
                lru.push(node.memo.args);
            }
            return node.memo.result;
        }
        const result = fn(...args);
        node.memo = {
            args,
            result,
        };
        if (!infinite) {
            lru.push(args);
        }
        if (lru.length > limit) {
            const del = lru.shift();
            if (del) {
                let delNode = root;
                const parents = [];
                for (const arg of del) {
                    (0, typeAssertions_1.assertDefined)(delNode.children);
                    parents.push(delNode);
                    delNode = (0, __1.mapMustGet)(delNode.children, arg);
                }
                delete delNode.memo;
                for (let i = del.length - 1; i >= 0; i--) {
                    const arg = del[i];
                    const argParent = (0, typeAssertions_1.mustBeDefined)(parents[i]);
                    if (memoIsEmpty(delNode)) {
                        (0, typeAssertions_1.assertDefined)(argParent.children);
                        argParent.children.delete(arg);
                        delNode = argParent;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return result;
    };
}
exports.memoizeWithLRU = memoizeWithLRU;
//# sourceMappingURL=memo.js.map