"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotionObjectIndex = exports.fillCache = exports.getFromCache = void 0;
/**
 * This file implements a cache and cache implementation helpers.
 * @category Cache
 * @module
 */
const __1 = require("..");
/**
 * Either returns a value by calling `fromCache`, or by calling `fromScratch`,
 * depending on `cacheBehavior`.
 * @category Cache
 * @param cacheBehavior `"fill"` by default.
 * @param fromCache Function to read the value from the cache.
 * @param fromScratch Function to compute the value from scratch.
 * @returns `[value, hit]` where `hit` is `true` if the value was fetched from the cache.
 */
function getFromCache(cacheBehavior, fromCache, fromScratch) {
    const cached = cacheBehavior !== 'refresh' ? fromCache() : undefined;
    if (cached !== undefined) {
        return [cached, true];
    }
    return fromScratch().then((value) => [value, false]);
}
exports.getFromCache = getFromCache;
function fillCache(cacheBehavior, hitOrFill, maybeFill) {
    const hit = typeof hitOrFill === 'boolean' ? hitOrFill : false;
    const fill = typeof maybeFill === 'function' ? maybeFill : hitOrFill;
    if (cacheBehavior === 'read-only') {
        return;
    }
    if (hit && cacheBehavior !== 'refresh') {
        return;
    }
    fill();
}
exports.fillCache = fillCache;
/**
 * Stores values from the Notion API.
 * @category Cache
 */
class NotionObjectIndex {
    constructor() {
        /** Whole pages */
        this.page = new Map();
        this.pageWithChildren = new Map();
        /** Whole blocks */
        this.block = new Map();
        this.blockWithChildren = new Map();
        /** Assets inside a block, page, etc. These are keyed by `getAssetRequestKey`. */
        this.asset = new Map();
        /** Parent block ID, may also be a page ID. */
        this.parentId = new Map();
        /** Parent page ID. */
        this.parentPageId = new Map();
    }
    addBlock(block, parent) {
        const oldBlockWithChildren = this.blockWithChildren.get(block.id);
        this.block.set(block.id, block);
        if ('children' in block) {
            this.blockWithChildren.set(block.id, block);
        }
        else if (oldBlockWithChildren) {
            // Try to upgrade to a block with children by re-using old children
            const asBlockWithChildren = block;
            asBlockWithChildren.children = oldBlockWithChildren.children;
            this.blockWithChildren.set(block.id, asBlockWithChildren);
        }
        const parentId = typeof parent === 'string'
            ? parent
            : typeof parent === 'object'
                ? parent.id
                : undefined;
        if (parentId) {
            this.parentId.set(block.id, parentId);
        }
        // If we don't know parent type, ignore.
        const parentPageId = typeof parent === 'object'
            ? parent.object === 'page'
                ? parent.id
                : parentId && this.parentPageId.get(parentId)
            : undefined;
        if (parentPageId) {
            this.parentPageId.set(block.id, parentPageId);
        }
    }
    addPage(page) {
        this.page.set(page.id, page);
        if ('children' in page) {
            this.pageWithChildren.set(page.id, page);
        }
        // Note: we don't try to upgrade `Page` since preserving old children can be more sketchy.
        switch (page.parent.type) {
            case 'page_id':
                this.parentId.set(page.id, page.parent.page_id);
                this.parentPageId.set(page.id, page.parent.page_id);
                break;
            case 'database_id':
                this.parentId.set(page.id, page.parent.database_id);
                this.parentPageId.set(page.id, page.parent.database_id);
                break;
        }
    }
    addAsset(request, asset) {
        const key = (0, __1.getAssetRequestKey)(request);
        this.asset.set(key, asset);
    }
}
exports.NotionObjectIndex = NotionObjectIndex;
//# sourceMappingURL=cache.js.map