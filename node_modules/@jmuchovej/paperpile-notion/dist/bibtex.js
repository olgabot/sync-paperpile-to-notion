"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diffBibTeX = exports.readBibTeX = void 0;
const tslib_1 = require("tslib");
require(`@citation-js/plugin-bibtex`);
const { Cite } = require(`@citation-js/core`);
const _ = (0, tslib_1.__importStar)(require("lodash"));
const node_fs_1 = require("node:fs");
const parseKeywords = (keywords) => {
    // eslint-disable-next-line eqeqeq
    if (keywords == undefined) {
        return { keywords: [] };
    }
    let status = keywords.find((k) => k.startsWith(`status:`));
    keywords = keywords.filter((k) => k.startsWith("status:"));
    status = status?.replace(/status:/, ``);
    let topics = keywords.filter((k) => k.startsWith(`topic:`));
    keywords = keywords.filter((k) => !topics.includes(k));
    topics = topics?.map((t) => t.replace(/topic:/, ``));
    let fields = keywords.filter((k) => k.startsWith(`field:`));
    keywords = keywords.filter((k) => !fields.includes(k));
    fields = fields?.map((t) => t.replace(/field:/, ``));
    let methods = keywords.filter((k) => k.startsWith(`method:`));
    keywords = keywords.filter((k) => !methods.includes(k));
    methods = methods?.map((t) => t.replace(/method:/, ``));
    return { status, topics, fields, methods, keywords };
};
const readBibTeX = (path) => {
    const file = (0, node_fs_1.readFileSync)(path, { encoding: `utf-8` });
    const { data: articles } = new Cite(file);
    const entries = {};
    return _.reduce(articles, (obj, citation) => {
        citation.keyword = citation.keyword?.replaceAll(",", ";");
        citation.keyword = citation.keyword?.split(";").map((x) => x.trim());
        citation = { ...citation, ...parseKeywords(citation.keyword) };
        const authors = citation.author ? citation.author : citation.editor;
        citation.authors = authors?.map(({ family, given }) => {
            return [given, family]
                .filter(e => e)
                .join(" ")
                .replaceAll(/[.*]/g, "");
        });
        // Notion doesn't allow Selects to be longer than 100 characters
        let venue = citation["container-title"];
        venue = truncate(venue, 100);
        venue = venue?.replaceAll(",", " ");
        citation["container-title"] = venue;
        const ID = citation["citation-label"];
        if (!_.isNil(citation.title) && !_.isNil(citation["citation-label"])) {
            obj[ID] = citation;
        }
        return obj;
    }, entries);
};
exports.readBibTeX = readBibTeX;
const diffBibTeX = (prev, curr) => {
    return _.keys(curr).map((key) => {
        // Short-circuit if this `key` is new
        if (!prev[key]) {
            console.log(`Found new entry at key: ${key}`);
            return key;
        }
        // The graph needs to be dropped since BibTeX ordering isn't preserved
        //   between Paperpile exports.
        const prevBibTeX = _.omit(prev[key], "_graph");
        const currBibTeX = _.omit(curr[key], "_graph");
        // Perform a deep comparison across objects to determine if they're
        //   different
        if (!_.isEqual(prevBibTeX, currBibTeX)) {
            console.log(`Entries differ at key: ${key}`);
            return key;
        }
    }).filter(k => k).reduce((obj, key) => {
        obj[key] = curr[key];
        return obj;
    }, {});
};
exports.diffBibTeX = diffBibTeX;
const truncate = (str, maxlen = 100) => {
    return (str?.length > maxlen) ? str.slice(0, maxlen - 3) + "..." : str;
};
