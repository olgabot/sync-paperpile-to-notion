"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const notion_api_1 = require("@jitl/notion-api");
const _ = (0, tslib_1.__importStar)(require("lodash"));
const base_1 = (0, tslib_1.__importDefault)(require("../../base"));
const notion_cms_1 = require("../../notion-cms");
class AuthorsClean extends base_1.default {
    async run() {
        await this.parse(AuthorsClean);
        if (!this.appConfig.hasAuthorDB) {
            this.error("You don't have an Authors database. Exiting.");
            this.exit(0); // analogous to this.exit(0), but keeps WebStorm from whining
        }
        const authorsCMS = (0, notion_cms_1.createCMS)(this.config, this.appConfig, this.notion, "authors");
        this.log(`Removing Authors with no Articles.`);
        const noArticlesFilter = authorsCMS.filter.articles.is_empty(true);
        await (0, notion_cms_1.archiveEmptyFilters)(this, authorsCMS, noArticlesFilter);
        this.log();
        this.log();
        this.log(`Attempting de-duplication based on "Aliases".`);
        await deduplicateAuthors(this, authorsCMS);
        this.log();
        this.log();
    }
}
exports.default = AuthorsClean;
AuthorsClean.summary = `Cleans up your Authors Database.`;
AuthorsClean.description = `
  1. Removes dangling authors with no articles.
  2. Attempts to clean up and merge authors and aliases.`;
AuthorsClean.args = base_1.default.args;
AuthorsClean.flags = base_1.default.flags;
AuthorsClean.examples = base_1.default.examples;
const deduplicateAuthors = async (CLI, cms) => {
    const Nicks = {};
    const Aliases = {};
    const filter = cms.filter.aliases.is_not_empty(true);
    for await (const author of cms.query({ filter })) {
        const { content: { id }, frontmatter: { name, aliases } } = author;
        const nick = (0, notion_api_1.richTextAsPlainText)(name).trim();
        const _aliases_ = (0, notion_api_1.richTextAsPlainText)(aliases)
            .split(";")
            .map((a) => a.trim())
            .filter((a) => a);
        Nicks[id] = nick;
        for (const alias of _aliases_) {
            Aliases[alias] = id;
        }
    }
    const articlesToCondense = {};
    const toArchive = [];
    for await (const [alias, pageID] of _.entries(Aliases)) {
        const matches = cms.filter.name.equals(alias);
        for await (const page of cms.query({ filter: matches })) {
            const { content: { id }, frontmatter: { name, articles } } = page;
            if (id === pageID && articles.length > 0) {
                CLI.warn(`Skipping pageID = ${id}, ${Nicks[id]}`);
                continue;
            }
            const Name = (0, notion_api_1.richTextAsPlainText)(name);
            CLI.log(`Collapsing ${Name}'s articles into ${Nicks[pageID]}...`);
            const relations = _.get(articlesToCondense, pageID, []);
            articlesToCondense[pageID] = [...relations, ...articles];
            toArchive.push({ page_id: id, archived: true });
        }
    }
    const toUpdate = _.map(articlesToCondense, (relation, page_id) => {
        return { page_id, relation };
    });
    CLI.log("Archiving detected duplicates...");
    await (0, notion_cms_1.batchEntries)(CLI, toArchive, async (entry) => {
        await cms.config.notion.pages.update(entry);
    });
    CLI.log("Migrating duplicates' articles to correct alias...");
    await (0, notion_cms_1.batchEntries)(CLI, toUpdate, async (entry) => {
        await cms.config.notion.pages.update(entry);
    });
};
