"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const base_1 = (0, tslib_1.__importDefault)(require("../../base"));
const notion_cms_1 = require("../../notion-cms");
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
const article_1 = require("../../models/article");
const notion_api_1 = require("@jitl/notion-api");
const perf_hooks_1 = require("perf_hooks");
class ArticlesSync extends base_1.default {
    async run() {
        await this.parse(ArticlesSync);
        const articleCMS = (0, notion_cms_1.createCMS)(this.config, this.appConfig, this.notion, "articles");
        let authorCMS;
        if (this.appConfig.hasAuthorDB) {
            authorCMS = (0, notion_cms_1.createCMS)(this.config, this.appConfig, this.notion, "authors");
        }
        const Status = this.appConfig.status.states;
        const parent = {
            database_id: this.appConfig.databases.articles.databaseID,
        };
        const toUpdate = [];
        const toCreate = [];
        const existingPages = await fetchDB(this.BibTeX, articleCMS);
        let counter = 0;
        let startTime = perf_hooks_1.performance.now(), endTime = perf_hooks_1.performance.now();
        for await (const [ID, article] of lodash_1.default.entries(this.BibTeX)) {
            article.status = lodash_1.default.isNil(article.status) ? undefined : Status[article.status];
            let { authors } = article;
            if (authors && this.appConfig.hasAuthorDB && authorCMS) {
                authors = await fetchAuthors(authors, authorCMS);
            }
            article.authors = authors?.filter((a) => a);
            const properties = (0, article_1.BibTeXToNotion)(this.appConfig, article);
            const page = existingPages[ID];
            if (page) {
                toUpdate.push({ page_id: page.content.id, properties });
            }
            else {
                toCreate.push({ parent, properties });
            }
            if (counter % 100 == 0) {
                endTime = perf_hooks_1.performance.now();
                const time = `${(endTime - startTime) / 1000 / 60}min`;
                console.log(`Cumulative time: ~${time}.`);
            }
            counter++;
        }
        await (0, notion_cms_1.batchEntries)(this, toCreate, async (entry) => {
            await articleCMS.config.notion.pages.create(entry);
        });
        await (0, notion_cms_1.batchEntries)(this, toUpdate, async (entry) => {
            await articleCMS.config.notion.pages.update(entry);
        });
    }
}
exports.default = ArticlesSync;
ArticlesSync.summary = `Syncs your Articles Database with the local BibTeX file.`;
ArticlesSync.description = `Strictly creates or updates articles based on the ID assigned by Paperpile.`;
ArticlesSync.args = base_1.default.args;
ArticlesSync.flags = base_1.default.flags;
ArticlesSync.examples = base_1.default.examples;
const fetchDB = async (BibTeX, cms) => {
    const db = {};
    const chunks = lodash_1.default.chain(BibTeX).keys().chunk(100).value();
    let batchId = 1;
    for await (const batch of chunks) {
        const filter = cms.filter.or(...batch.map((id) => cms.filter.ID.equals(id)));
        for await (const page of cms.query({ filter })) {
            const ID = (0, notion_api_1.richTextAsPlainText)(page.frontmatter.ID);
            db[ID] = page;
        }
        batchId++;
    }
    return db;
};
const fetchAuthors = async (authors, cms) => {
    const filter = cms.filter.or(...authors.map((author) => cms.filter.or(cms.filter.name.equals(author), cms.filter.aliases.contains(author))));
    const sortKeys = [];
    const relations = [];
    for await (const author of cms.query({ filter: filter })) {
        let { content: { id }, frontmatter: { name, aliases } } = author;
        name = (0, notion_api_1.richTextAsPlainText)(name);
        aliases = (0, notion_api_1.richTextAsPlainText)(aliases);
        const index = [name, ...aliases.split(";")].map((alias) => authors.indexOf(alias.trim())).find((n) => n > -1);
        if (index !== undefined) {
            relations.push({ id });
            sortKeys.push(index);
        }
    }
    return sortKeys.map((index) => relations[index]);
};
