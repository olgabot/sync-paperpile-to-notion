"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs_1 = require("fs");
const core_1 = require("@oclif/core");
const config_1 = require("./config");
const node_path_1 = (0, tslib_1.__importDefault)(require("node:path"));
const bibtex_1 = require("./bibtex");
const lodash_1 = (0, tslib_1.__importDefault)(require("lodash"));
const notion_api_1 = require("@jitl/notion-api");
const baseFlags = {
    config: core_1.Flags.string({
        char: `c`,
        description: `Path to your config file, if not in <%= config.configDir %>/config.js.`,
    }),
    help: core_1.Flags.help({ char: `h` }),
    token: core_1.Flags.string({
        char: `t`,
        env: `NOTION_INTEGRATION_TOKEN`,
        description: `Your Notion Integration Token. (NOTE: If you specify an environment variable of 'NOTION_INTEGRATION_TOKEN', that may be used.)`,
        required: true,
    }),
};
const baseArgs = [
    {
        name: `bibtexPath`,
        required: true,
        hidden: false,
        description: `Path to the BibTeX file you would like to sync with Notion.`,
    },
    {
        name: `bibtexDiff`,
        required: false,
        hidden: false,
        description: `Path to the BibTeX file you would like to diff "bibtexPath" against.`,
    },
];
const loadConfig = async (configDir, configPath, notion) => {
    configPath = configPath ?
        node_path_1.default.join(process.cwd(), configPath) :
        node_path_1.default.join(configDir, "config.js");
    const { default: obj } = await Promise.resolve().then(() => (0, tslib_1.__importStar)(require(configPath)));
    return await (0, config_1.newConfig)(obj, notion);
};
class BaseCommand extends core_1.Command {
    // Solved from: https://github.com/oclif/oclif/issues/225#issuecomment-574484114
    async init() {
        const { args, flags } = await this.parse(this.constructor);
        this.notion = new notion_api_1.NotionClient({
            auth: flags.token,
            logger: notion_api_1.NotionClientDebugLogger,
        });
        this.appConfig = await loadConfig(this.config.configDir, flags?.config, this.notion);
        let bibtex;
        const currBibTeX = (0, bibtex_1.readBibTeX)(args.bibtexPath);
        console.log(`Found ${lodash_1.default.keys(currBibTeX).length} entries`);
        if (args.bibtexDiff && (0, fs_1.existsSync)(args.bibtexDiff)) {
            const prevBibTeX = (0, bibtex_1.readBibTeX)(args.bibtexDiff);
            bibtex = (0, bibtex_1.diffBibTeX)(prevBibTeX, currBibTeX);
            console.log(`Reduced to ${lodash_1.default.keys(bibtex).length} entries`);
        }
        else {
            bibtex = currBibTeX;
        }
        this.BibTeX = bibtex;
        this.BibTeXAuthors = lodash_1.default.chain(this.BibTeX).values().flatMap((o) => o.authors).uniq().filter().value();
        await super.init();
    }
    async catch(err) {
        return super.catch(err);
    }
    async finally(err) {
        return super.finally(err);
    }
}
BaseCommand.strict = true;
BaseCommand.flags = baseFlags;
BaseCommand.args = baseArgs;
BaseCommand.examples = [
    "<%= config.bin %> <%= command.id %> /path/to/references.bib",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib -c /path/to/paperpile-notion.config.js",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib -t <your-integration-token>",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib -t <your-integration-token> -c /path/to/paperpile-notion.config.js",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib /path/to/your/previous/references.bib",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib /path/to/your/previous/references.bib -t <your-integration-token>",
    "<%= config.bin %> <%= command.id %> /path/to/references.bib /path/to/your/previous/references.bib -t <your-integration-token> -c /path/to/paperpile-notion.config.js",
];
exports.default = BaseCommand;
